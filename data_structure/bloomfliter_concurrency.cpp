#include "tbbscan/data_structure/bloomfliter_concurrency.hpp"

namespace concurrency
{
		//Create Bloom filter
    const utils::filter_policy *newbloom_filter_policy(int bits_per_key)
    {
        return new bloom_filter_policy(bits_per_key);
    }

    void bloom_filter_policy::create_filter(const utils::slice *keys,
            int n,
            std::string *dst) const
    {
        // Compute bloom filter size (in both bits and bytes)
        size_t bits = n * bits_per_key_;

        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) bits = 64;

        size_t bytes = (bits + 7) / 8;
        bits = bytes * 8;

        const size_t init_size = dst->size();
        dst->resize(init_size + bytes, 0);
        dst->push_back(static_cast<char>(k_));  // Remember # of probes in filter
        char *array = &(*dst)[init_size];

        for (size_t i = 0; i < (size_t)n; i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            uint32_t h = bloom_hash(keys[i]);
            const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits

            for (size_t j = 0; j < k_; j++) {
                const uint32_t bitpos = h % bits;
                array[bitpos/8] |= (1 << (bitpos % 8));
                h += delta;
            }
        }
    }

    bool bloom_filter_policy::key_may_match(const utils::slice& key,
            const utils::slice& bloom_filter) const
    {
        const size_t len = bloom_filter.size();

        if (len < 2) return false;

        const char *array = bloom_filter.data();
        const size_t bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        const size_t k = array[len-1];

        if (k > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        uint32_t h = bloom_hash(key);
        const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits

        for (size_t j = 0; j < k; j++) {
            const uint32_t bitpos = h % bits;

            if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;

            h += delta;
        }

        return true;
    }


}


